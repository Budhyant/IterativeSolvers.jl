<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="user_manual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#ConvergenceHistory-1">ConvergenceHistory</a></li><li><a class="toctext" href="#KrylovSubspace-1">KrylovSubspace</a></li><li><a class="toctext" href="#Define-function-as-matrix-1">Define function as matrix</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="library/public.html">Public</a></li><li><a class="toctext" href="library/internal.html">Internal</a></li></ul></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="user_manual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/IterativeSolvers.jl/tree/4584403fd7dd2367dd3044262a4f417642517be3/docs/src/user_manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package can be installed with a simple instruction.</p><pre><code class="language-julia">julia&gt; Pkg.add(&quot;IterativeSolvers&quot;)</code></pre><p>After installing the package, if you wish to use the latest features of the package you must switch to the master branch with <code>Pkg.clone</code>.</p><pre><code class="language-julia">julia&gt; Pkg.checkout(&quot;IterativeSolvers&quot;)</code></pre><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><p>All linear-algebraic routines will take as input a linear operator <code>A</code> that maps vectors to vectors. <code>A</code> is not explicitly typed, but must either be a <a href="library/public.html#IterativeSolvers.KrylovSubspace"><code>KrylovSubspace</code></a> or support multiplication <code>*</code> or function composition (apply) that behave as necessary to produce the correct mapping on the vector space.</p><p>A custom type for <code>A</code> may be specified. The following interface is expected to be defined on <code>A</code>:</p><p><code>A*v</code> is defined and computes the matrix-vector product on a <code>v::Vector</code>.</p><p><code>eltype(A)</code> is defined and returns the element type implicit in the equivalent matrix representation of <code>A</code>.</p><p><code>size(A, d)</code> is defined and returns the nominal dimensions along the dth axis in the equivalent matrix representation of <code>A</code>.</p><h3><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h3><p>All linear solvers have a common function declaration (with a few exceptions).</p><pre><code class="language-none">solver(A, b::Vector; kwargs...)
solver!(x, A, b::Vector; kwargs...)</code></pre><p>In the case of eigenproblems or singular value decompositions:</p><pre><code class="language-none">eigsolver(A; kwargs...)
eigsolver!(x, A; kwargs...)</code></pre><p><code>A</code> is a linear operator as described above.</p><p><code>b</code> is the vector to be solved.</p><p><code>x</code> is a vector for the initial guess. In the case of a mutating call this parameter will be overwritten. (Mutating functions end with <code>!</code>)</p><p>Output will be the solution to the system.</p><h3><a class="nav-anchor" id="Additional-arguments-1" href="#Additional-arguments-1">Additional arguments</a></h3><p>Keyword names will vary depending on the method, however some of them will always have the same spelling:</p><p><code>tol</code>: stopping tolerance of the method. When a method accepts more than one tolerance they are enumerated  with a letter prefix, e.g <code>atol</code>, <code>btol</code>, <code>ctol</code>, etc.</p><p><code>verbose</code>: print information about the running method.</p><p><code>maxiter</code>: maximum number of allowed iterations.</p><p><code>Pl</code>: left preconditioner. (When applicable)</p><p><code>Pr</code>: right preconditioner. (When applicable)</p><p><code>log::Bool = false</code>: output an extra element of type <code>ConvergenceHistory</code> containing extra information of the method execution.</p><p><code>plot</code>: plot information relevant to the method. (Only for <code>Master</code> version)</p><h3><a class="nav-anchor" id="log-keyword-1" href="#log-keyword-1"><code>log</code> keyword</a></h3><p>All solvers contain the <code>log</code> keyword. This is to be used when obtaining more information is required, to use it place the set <code>log</code> to <code>true</code>.</p><pre><code class="language-julia">x, ch = cg(Master, rand(10, 10), rand(10) log=true)
svd, L, ch = svdl(Master, rand(100, 100), plot=true, log=true)</code></pre><p>The function will now return one more parameter of type <code>ConvergenceHistory</code>.</p><p><em><code>Note:</code></em>  Keyword argument <code>plot</code> is only available when <code>log</code> is set.</p><h2><a class="nav-anchor" id="ConvergenceHistory-1" href="#ConvergenceHistory-1">ConvergenceHistory</a></h2><p>A <a href="library/public.html#IterativeSolvers.ConvergenceHistory"><code>ConvergenceHistory</code></a> instance stores information of a solver.</p><p>Number of iterations.</p><pre><code class="language-julia">ch.iters</code></pre><p>Convergence status.</p><pre><code class="language-julia">ch.isconverged</code></pre><p>Stopping tolerances. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:tol]</code></pre><p>Maximum number of iterations per restart. (Only on restarted methods)</p><pre><code class="language-julia">nrests(ch)</code></pre><p>Number of matrix-vectors and matrix-transposed-vector products.</p><pre><code class="language-julia">nprods(ch)</code></pre><p>Data stored on each iteration, accessed information can be either a vector or matrix. This data can be a lot of things, most commonly residual. (A <code>Symbol</code> key is needed to access)</p><pre><code class="language-julia">ch[:resnorm] #Vector or Matrix
ch[:resnorm, x] #Vector or Matrix element
ch[:resnorm, x, y] #Matrix element</code></pre><p>The available keys of each method is described in the <a href="library/public.html#Public-Documentation-1">Public Documentation</a>.</p><h3><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h3><p><code>ConvergeHistory</code> provides a recipe to use with the package <a href="https://github.com/tbreloff/Plots.jl">Plots.jl</a>, this makes it really easy to plot on different plot backends. There are two recipes provided:</p><p>One for the whole <code>ConvergenceHistory</code>.</p><pre><code class="language-julia">plot(ch)</code></pre><p>The other one to plot data binded to a key.</p><pre><code class="language-julia">_, ch = gmres(rand(10,10), rand(10), maxiter = 100, log=true)
plot(ch, :resnorm, sep = :blue)</code></pre><p><em>Plot additional keywords</em></p><p><code>sep::Symbol = :white</code>: color of the line separator in restarted methods.</p><h2><a class="nav-anchor" id="KrylovSubspace-1" href="#KrylovSubspace-1">KrylovSubspace</a></h2><p>When <a href="library/public.html#IterativeSolvers.KrylovSubspace"><code>KrylovSubspace</code></a> is supported by the method, <code>A</code> can be replaced by an instance <code>K</code> of it. To check if a certain function supports it use   <code>methods</code> or <code>?</code> to find out, if there is a <code>K</code> in the argument list then it does.</p><pre><code class="language-julia">julia&gt; ?cg!

    cg!(x, A, b)
    cg!(x, K, b)

    ...</code></pre><p><code>KrylovSubspace</code> is only allowed on functions that accept <code>x</code> as an argument, that&#39;s why <code>cg</code> doesn&#39;t allow it. This is also true when <code>x</code> is a keyword as is the case of <code>powm</code>.</p><pre><code class="language-julia">julia&gt; ?cg!

    powm(A)
    powm(K)

    ...</code></pre><p>The <code>KrylovSubspace</code> type collects information on the Krylov subspace generated over the course of an iterative Krylov solver.</p><p>Recall that the Krylov subspace of order r given a starting vector <code>b</code> and a linear operator <code>A</code> is spanned by the vectors <code>[b, A*b, A^2*b,... A^(r-1)*b]</code>. Many modern iterative solvers work on Krylov spaces which expand until they span enough of the range of <code>A</code> for the solution vector to converge. Most practical algorithms, however, will truncate the order of the Krylov subspace to save memory and control the accumulation of roundoff errors. Additionally, they do not work directly with the raw iterates <code>A^n*b</code>, but will orthogonalize subsequent vectors as they are computed so as to improve numerical stability. <code>KrylovSubspace</code>s provide a natural framework to express operations such as a (possibly non-orthonormalized) basis for the Krylov subspace, retrieving the next vector in the subspace, and orthogonalizing an arbitrary vector against (part or all of) the subspace.</p><p>The implementation of <code>KrylovSubspace</code> in this package differs from standard textbook presentations of iterative solvers. First, the <code>KrylovSubspace</code> type shows clearly the relationship between the linear operator A and the sequence of basis vectors for the Krylov subspace that is generated by each new iteration. Second, the grouping together of basis vectors also makes the orthogonalization steps in each iteration routine clearer. Third, unlike in other languages, the powerful type system of Julia allows for a simplified notation for iterative algorithms without compromising on performance, and enhances code reuse across multiple solvers.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>A <a href="library/public.html#IterativeSolvers.KrylovSubspace"><code>KrylovSubspace</code></a> can be initialized by three constructors, depending on the type of the linear operator:</p><pre><code class="language-none">KrylovSubspace{T}(A::AbstractMatrix{T}, [order::Int, v::Vector{Vector{T}}])

KrylovSubspace{T}(A::KrylovSubspace{T}, [order::Int, v::Vector{Vector{T}}])

KrylovSubspace(A, n::Int, [order::Int, v::Vector{Vector{T}}])</code></pre><p><code>A</code>: The linear operator associated with the <code>KrylovSubspace</code>.</p><p><code>order</code>: the order of the <code>KrylovSubspace</code>, i.e. the maximal number of Krylov vectors to remember.</p><p><code>n</code>: the dimensionality of the underlying vector space <code>T^n</code>.</p><p><code>v</code>: the iterable collection of Krylov vectors (of maximal length order).</p><p>The dimensionality of the underlying vector space is automatically inferred where possible, i.e. when the linear operator is an <code>AbstractMatrix</code> or <code>KrylovSubspace</code>.</p><p><em><code>Note:</code></em> second constructor destroys the old <code>KrylovSubspace</code>.</p><h3><a class="nav-anchor" id="Orthogonalization-1" href="#Orthogonalization-1">Orthogonalization</a></h3><p>Orthogonalizing the basis vectors for a <code>KrylovSubspace</code> is crucial for numerical stability, and is a core low-level operation for many iterative solvers.</p><pre><code class="language-none">orthogonalize{T}(v::Vector{T}, K::KrylovSubspace{T}, [p::Int]; [method::Symbol], [normalize::Bool])</code></pre><p><code>v</code>: vector to orthogonalize.</p><p><code>K</code>: <code>KrylovSubspace</code> to orthogonalize against.</p><p><code>p</code>: number of Krylov vectors to orthogonalize against. (Default is all available)</p><p><code>method</code>: Orthogonalization method. Currently supported methods are:</p><ul><li><p><code>:GramSchmidt</code></p></li><li><p><code>:ModifiedGramSchmidt</code> (default)</p></li><li><p><code>:Householder</code>.</p></li></ul><h2><a class="nav-anchor" id="Define-function-as-matrix-1" href="#Define-function-as-matrix-1">Define function as matrix</a></h2><p>This package supports the use of <a href="https://github.com/Jutho/LinearMaps.jl">LinearMaps.jl</a> for creating matrices using custom functions.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="library/public.html"><span class="direction">Next</span><span class="title">Public</span></a></footer></article></body></html>
