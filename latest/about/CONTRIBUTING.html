<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contributing · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../user_manual.html">Manual</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../library/public.html">Public</a></li><li><a class="toctext" href="../library/internal.html">Internal</a></li></ul></li><li><span class="toctext">About</span><ul><li class="current"><a class="toctext" href="CONTRIBUTING.html">Contributing</a><ul class="internal"><li><a class="toctext" href="#Setting-workspace-up-1">Setting workspace up</a></li><li><a class="toctext" href="#Adding-or-modifying-iterative-methods-1">Adding or modifying iterative methods</a></li><li><a class="toctext" href="#Adding-benchmarks-1">Adding benchmarks</a></li></ul></li><li><a class="toctext" href="license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>About</li><li><a href="CONTRIBUTING.html">Contributing</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/IterativeSolvers.jl/tree/4584403fd7dd2367dd3044262a4f417642517be3/docs/src/about/CONTRIBUTING.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Contributing-1" href="#Contributing-1">Contributing</a></h1><p>Contributions are always welcome, as are feature requests and suggestions. Feel free to open <a href="https://help.github.com/articles/creating-an-issue/">issues</a> and <a href="https://help.github.com/articles/creating-a-pull-request/">pull requests</a> at any time. If you aren&#39;t familiar with git or Github please start <a href="https://help.github.com/articles/good-resources-for-learning-git-and-github/">now</a>.</p><p>It is important to note that almost every method in the package has documentation, to know what it does simply use <code>?&lt;method&gt;</code> in the terminal.</p><pre><code class="language-julia">julia&gt; using IterativeSolvers

help?&gt; IterativeSolvers.Adivtype
  Adivtype(A, b)

  Determine type of the division of an element of b against an element of A:

  typeof(one(eltype(b))/one(eltype(A)))</code></pre><h2><a class="nav-anchor" id="Setting-workspace-up-1" href="#Setting-workspace-up-1">Setting workspace up</a></h2><p>Julia&#39;s internal package manager makes it easy to install and modify packages from Github. Any package hosted on Github can be installed via <code>Pkg.clone</code> by providing the <a href="https://help.github.com/articles/which-remote-url-should-i-use/">repository&#39;s URL</a>, so installing a fork on your system is a simple task.</p><pre><code class="language-julia">Pkg.clone(&quot;https://github.com/johndoe/IterativeSolvers.jl&quot;)</code></pre><p>It is to note here if you have the original package installed the fork will replace it, this is not a problem.</p><p>Now find your fork&#39;s location.</p><pre><code class="language-julia">Pkg.dir(&quot;IterativeSolvers&quot;)</code></pre><p>Once there you will notice you are on the master branch, whenever a package is imported Julia will use the code in the current branch, this means checking out other git branches will let you use/test whatever there is.</p><h2><a class="nav-anchor" id="Adding-or-modifying-iterative-methods-1" href="#Adding-or-modifying-iterative-methods-1">Adding or modifying iterative methods</a></h2><p>Each iterative method method must log information using the inner <code>ConvergenceHistory</code> type. When information is not necessary to be stored (plot is set to <code>false</code>) then instead of <code>ConvergenceHistory</code> create a <code>DummyHistory</code>, this type has the same calls <code>ConvergenceHistory</code> does but without storing anything.</p><p>There are two types of <code>ConvergenceHistory</code>: plain and restarted. The only real difference between the two is how they are plotted and how the number of restarts is calculated, everything else is the same.</p><p>Before logging information space must always be reserved.</p><pre><code class="language-julia">log = ConvergenceHistory()
log[:tol] = tol
reserve!(log,:betas, maxiter) # Vector of length maxiter
reserve!(log,:conv, maxiter, T=BitArray) # Vector of length maxiter
reserve!(log,:ritz, maxiter, k) # Matrix of size (maxiter, k)</code></pre><p>To store information at each iteration use <code>push!</code>.</p><pre><code class="language-julia">push!(log, :conv, conv)
push!(log, :ritz, F[:S][1:k])
push!(log, :betas, L.β)</code></pre><p>To advance the log index to the next iteration use <code>nextiter!</code>.</p><pre><code class="language-julia">nextiter!(log)</code></pre><p>A more detailed explanation of all the functions is in both the public and internal documentation of <code>ConvergenceHistory</code>.</p><p>The most rich example of the usage of <code>ConvergenceHistory</code> is in <code>svdl</code>.</p><h2><a class="nav-anchor" id="Adding-benchmarks-1" href="#Adding-benchmarks-1">Adding benchmarks</a></h2><p>The <a href="@ref">Benchmarks</a> tab of the documentation is built automatically with Travis. Any benchmark added will be displayed automatically after a successful pull request.</p><p>The benchmark suite gets built doing a cross product between the available matrices and available methods, if there are <code>n</code> methods and <code>m</code> linear operators then <code>n*m</code> will be the upper limit of benchmarks to be made. Some methods are not compatible with certain matrices, to avoid generating unnecessary benchmarks each method and matrix has traits, linear operator traits are inspired from <a href="http://matrixdepotjl.readthedocs.io/en/latest/properties.html">MatrixDepot.jl</a>.</p><p><strong>Method traits</strong></p><ul><li><p>accessible : Method accesses the linear operator&#39;s fields.</p></li><li><p>inverse    : <code>A</code>&#39;s Inverse must exist.</p></li><li><p>symmetric  : <code>A</code>&#39;s must be symmetric.</p></li><li><p>pos-def    : <code>A</code>&#39;s must be definite.</p></li></ul><p><strong>Linear Operator traits</strong></p><ul><li><p>accessible : Is accessible.</p></li><li><p>inverse    : <code>A</code> is exist.</p></li><li><p>symmetric  : <code>A</code> is symmetric.</p></li><li><p>pos-def    : <code>A</code> is definite.</p></li><li><p>eigen      : Part of the eigensystem of the matrix is explicitly known.</p></li><li><p>graph      : An adjacency matrix of a graph.</p></li><li><p>ill-cond   : The matrix is ill-conditioned for some parameter values.</p></li><li><p>random     : The matrix has random entries.</p></li><li><p>regprob    : The output is a test problem for Regularization Methods.</p></li><li><p>sparse     : The matrix is sparse.</p></li></ul><p>A benchmark between a method and a linear operator will be made if and only if the traits of the method is subset of the traits of the linear operator.</p><p>Benchmarks are stored in <a href="https://github.com/JuliaLang/IterativeSolvers.jl/tree/master/benchmark/Benchmarks.jl">Benchmarks.jl</a>. To add a method use <code>addEqMethod</code>.</p><pre><code class="language-julia">addEqMethod(methods, &quot;jacobi&quot;, jacobi, [&quot;inverse&quot;,&quot;accessible&quot;])
addEqMethod(methods, &quot;gauss_seidel&quot;, gauss_seidel, [&quot;inverse&quot;,&quot;accessible&quot;])
addEqMethod(methods, &quot;sor&quot;, sor, [&quot;inverse&quot;,&quot;accessible&quot;])
addEqMethod(methods, &quot;ssor&quot;, ssor, [&quot;inverse&quot;,&quot;accessible&quot;, &quot;symmetric&quot;])
addEqMethod(methods, &quot;cg&quot;, cg, [&quot;inverse&quot;, &quot;symmetric&quot;, &quot;pos-def&quot;])
addEqMethod(methods, &quot;gmres&quot;, gmres, [&quot;inverse&quot;])
addEqMethod(methods, &quot;lsqr&quot;, lsqr, [&quot;inverse&quot;])
addEqMethod(methods, &quot;chebyshev&quot;, chebyshev, [&quot;inverse&quot;, &quot;accessible&quot;])</code></pre><p>Here <code>methods</code> is a dictionary, the second argument is the name to be displayed in the benchmarks, the third argument is the function and the fourth is the traits. Every function has a predetermined call in <code>buildCall</code> function.</p><p>To add an equation use <code>addEquation</code>.</p><pre><code class="language-julia">#Sparse matrix equations
addEquation(
    equations, &quot;Poisson&quot;, [&quot;Sparse&quot;, &quot;Poisson&quot;],
    [&quot;sparse&quot;,&quot;inverse&quot;, &quot;symmetric&quot;, &quot;pos-def&quot;, &quot;eigen&quot;, &quot;accessible&quot;],
    :(matrixdepot(&quot;poisson&quot;,4))
    )

#Function matrix equations
addEquation(
    equations, &quot;SOLtest&quot;, [&quot;Function&quot;, &quot;SOLtest&quot;],
    [&quot;function&quot;,&quot;inverse&quot;],
    :(buildSol(10)),
    10
)</code></pre><p>Here <code>equations</code> is a dictionary, the second argument is the name to be displayed in the benchmarks, the third argument is the path inside the <code>BenchmarkGroup</code> type the fourth argument is the traits, the fifth is the matrix generator and the sixth is the size of the matrix. The size of the matrix has to be passed when it is impossible to deduce the dimension from the generator, in this case buildSol generates a function and not a matrix.</p><p>To add a custom benchmark use directly the <code>suite</code> variable which is the <code>BenchmarkGroup</code> of the package, to know more of this type check <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a>.</p><footer><hr/><a class="previous" href="../library/internal.html"><span class="direction">Previous</span><span class="title">Internal</span></a><a class="next" href="license.html"><span class="direction">Next</span><span class="title">License</span></a></footer></article></body></html>
